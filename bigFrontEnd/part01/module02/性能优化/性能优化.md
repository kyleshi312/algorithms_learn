### javascript 
    * 内存管理
      * 内存 - 由可读单元组成，表示一片
        * 申请内存
          `let obj = {}`
        * 使用内存
        * `obj.name = 'log'`
        * 释放内存
        * `obj = null`
        * 管理流程 - 申请——使用——释放
      * 垃圾
        * 内存管理是自动的
        * 不被引用
        * 不能从根上访问到
        * 可达对象
          * 能访问到的对象
          * 可达的标准 - 从根（全局执行上下文）出发 
          *  全局变量
       * 引用与可达
         * ```
         * let obj = {name: 'xm'}
         * ```
    * 垃圾回收与常见GC算法
      * GC - 垃圾回收机制简写
        * 找到内存中垃圾，并释放
        * 找到，释放，回收 —— 垃圾空间
        * 不需要使用
        * 不能再访问
      * 算法 —— 查找和回收的规则
        * 引用计数
          * 核心： 设置引用数，判断为0
          * 引用计数器
            * 引用关系改变时修改引用数
              * 对象空间 - 有变量指向 +1，减少-1，为0时回收
            * 为0时，立即回收
            * 效率不一样
          * 优点：
            * 发现，立即回收
            * 最大限度减少程序暂停、程序卡顿
          * 缺点：
            * 没有办法处理循环引用的对象，不能触发
            * 时间开销大，资源消耗
              * 维护一个数值的变化
        * 标记清除
          * 分标记，清除两个阶段
            * 遍历标记活动对象
            * 遍历清除没有标记的对象
            * 回收相应空间，放在空闲列表
            * 优点：
              * 不可达对象，局部作用域可处理，循环引用可分析处理
            * 缺点：
              * 地址分散，容易产生碎片空间
              * 不会立即回收，
            * 
        * 标记整理
          * 标记清除的增强
          * 先执行整理，移动对象位置，把内存变成连续的位置
          * 优点：
            * 减少碎片化空间
          * 缺点：
            * 不会立即回收
        * 分代回收（V8）
* 总结：
  * 引用计数为0   
    * 即时回收
    * 减少卡顿时间
    * 无法回收recular reference
    * 资源消耗大
  * 标记清除 两个阶段
    * 回收recular reference
    * 产生碎片空间
    * 不会立即回收
    * 标记活动对象
  * 整理为连续
    * 减少碎片空间
    * 不会立即回收
  * 
  * V8引擎
    * 主流引擎
    * 即时编译
      * 传统 - 源代码编译为字节码
    * 内存设限
      * 符合增强标记工作原理
      * 64位不超过1.5G
      * 32位不超过800M
    * 回收策略
      * 堆里的数据
      * 分代回收
        * V8内存一分为二
          * 小空间
          * 大空间
        * 新生代 老生代
          * 新生代
            * 小空间存储新生代（32M | 16M）
            * 存活时间短的对象
            * 新生代内存空间分为两个等大的空间
            * from——使用状态
            *  to ——空闲状态
            * 当前使用from，触发GC后拷贝From 到 to
            * 复制算法 标记整理算法
            * 触发晋升操作
              * 一轮GC后还存活 需要晋升
              * to空间使用率不能超过25%，保证from空间的可用空间足够大
            * 标记整理将活动对象拷贝到to
            * from 与 To交换空间完成释放
            * 出现晋升 - 新生代
          * 老生代
            * 存活是
            * 64位1.4G,32位700M 
            * 标记清除
            * 标记整理
            * 增量标记
          * 细节对比
            * 新生代 - 空间换时间
            * 空间太大
            * 老生代 - 比较大不适合，复制消耗时间多
        * 不同对象不同算法
      * 空间复制
      * 标记清除
      * 标记整理
      * 标记增量
        * 程序停止
        * 回收过程
        * 拆分为多个小步 - 程序执行与垃圾回收交替进行
    * V8
      * 内存设置上限
      * 基于分代思想
      * 新生代，老生代
* Perfomance
* 内存问题的外在表现
  * 页面延迟，经常性暂停
  * 持续性出席那糟糕性能
  * 页面性能时间越长越糟糕
* 界定问题标准
  * 内存泄漏 - 内存使用持续升高
  * 内存膨胀 - 在多数设备上都
  * 存在性能问题
* 监控方式
  * 任务管理器
    * shift + ESC
    * DOM内存
    * js的堆 可达对象使用的大小
  * Timeline时序图记录
    * 
  * 堆快照查找分离DOM
  * 判断是否存在频繁的垃圾回收
